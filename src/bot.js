import { Bot, InputFile } from 'grammy';
import { addSubscriber, removeSubscriber, getSubscriber, getAllActiveSubscribers, searchAnnonces, getLatestParution } from './database.js';

/**
 * Envoie une notification √† l'administrateur lors d'une action d'abonnement/d√©sabonnement
 * @param {Bot} bot - Instance du bot Telegram
 * @param {string} action - Type d'action : 'subscribe' ou 'unsubscribe'
 * @param {object} userData - Informations sur l'utilisateur
 * @param {string} userData.nom - Nom de l'utilisateur
 * @param {string} userData.username - Username Telegram (optionnel)
 * @param {number} userData.chatId - ID du chat
 * @param {Date} userData.date - Date de l'action
 * @param {string|null} error - Message d'erreur si l'action a √©chou√©
 */
async function notifyAdmin(bot, action, userData, error = null) {
  const adminChatId = process.env.ADMIN_CHAT_ID;

  // Si ADMIN_CHAT_ID n'est pas configur√©, ne pas envoyer de notification
  if (!adminChatId) {
    console.log('‚ö†Ô∏è ADMIN_CHAT_ID non configur√© - notification admin ignor√©e');
    return;
  }

  try {
    // R√©cup√©rer le nombre total d'abonn√©s actifs
    const activeSubscribers = await getAllActiveSubscribers();
    const totalActifs = activeSubscribers.length;

    // D√©terminer l'emoji et le texte de l'action
    const actionEmoji = action === 'subscribe' ? 'üì•' : 'üì§';
    const actionText = action === 'subscribe' ? 'Nouvel abonnement' : 'D√©sabonnement';
    const statusEmoji = error ? '‚ùå' : '‚úÖ';
    const statusText = error ? '√âCHEC' : 'SUCC√àS';

    // Construire le message
    let message = `${actionEmoji} *${actionText}* - ${statusEmoji} ${statusText}\n\n`;

    message += `üë§ *Utilisateur :*\n`;
    message += `   ‚Ä¢ Nom : ${userData.nom}\n`;
    if (userData.username) {
      message += `   ‚Ä¢ Username : @${userData.username}\n`;
    }
    message += `   ‚Ä¢ Chat ID : \`${userData.chatId}\`\n`;
    message += `   ‚Ä¢ Date : ${userData.date.toLocaleString('fr-FR')}\n\n`;

    if (error) {
      message += `‚ö†Ô∏è *Erreur :*\n${error}\n\n`;
    }

    message += `üìä *Statistiques :*\n`;
    message += `   ‚Ä¢ Total abonn√©s actifs : ${totalActifs}`;

    // Envoyer la notification √† l'admin
    await bot.api.sendMessage(adminChatId, message, {
      parse_mode: 'Markdown'
    });

    console.log(`‚úÖ Notification admin envoy√©e pour ${actionText}`);
  } catch (notifyError) {
    // Ne pas bloquer le flux principal si la notification √©choue
    console.error('‚ùå Erreur lors de l\'envoi de la notification admin:', notifyError);
  }
}

/**
 * Envoie un rapport d'extraction √† l'administrateur
 * @param {Bot} bot - Instance du bot Telegram
 * @param {object} parutionInfo - Informations sur la parution
 * @param {object} extractionStats - Statistiques d'extraction d√©taill√©es
 * @param {number} durationMs - Dur√©e totale en millisecondes
 * @param {number} savedCount - Nombre d'annonces sauvegard√©es
 * @param {number} saveErrors - Nombre d'erreurs de sauvegarde
 */
export async function notifyExtractionAdmin(bot, parutionInfo, extractionStats, durationMs, savedCount, saveErrors) {
  const adminChatId = process.env.ADMIN_CHAT_ID;

  // Si ADMIN_CHAT_ID n'est pas configur√©, ne pas envoyer de notification
  if (!adminChatId) {
    console.log('‚ö†Ô∏è ADMIN_CHAT_ID non configur√© - notification d\'extraction ignor√©e');
    return;
  }

  try {
    // D√©terminer le statut global
    const hasErrors = extractionStats.pagesErrors > 0 || saveErrors > 0;
    const isPartialSuccess = hasErrors && extractionStats.pagesSuccess > 0;
    const isFullFailure = extractionStats.pagesSuccess === 0;

    // Emoji et texte de statut
    let statusEmoji, statusText;
    if (isFullFailure) {
      statusEmoji = '‚ùå';
      statusText = '√âCHEC COMPLET';
    } else if (isPartialSuccess) {
      statusEmoji = '‚ö†Ô∏è';
      statusText = 'SUCC√àS PARTIEL';
    } else {
      statusEmoji = '‚úÖ';
      statusText = 'SUCC√àS';
    }

    // Formater la dur√©e
    const minutes = Math.floor(durationMs / 60000);
    const seconds = Math.floor((durationMs % 60000) / 1000);
    const durationStr = minutes > 0 ? `${minutes}min ${seconds}s` : `${seconds}s`;

    // Construire le message
    let message = `üéØ *EXTRACTION TERMIN√âE* - ${statusEmoji} ${statusText}\n\n`;

    message += `üì∞ *Parution*\n`;
    message += `   ‚Ä¢ N¬∞${parutionInfo.numero} (${parutionInfo.periode})\n`;
    message += `   ‚Ä¢ ‚è±Ô∏è Dur√©e : ${durationStr}\n\n`;

    message += `üìä *Statistiques globales*\n`;
    message += `   ‚Ä¢ Pages trait√©es : ${extractionStats.pagesSuccess}/${extractionStats.totalPages}\n`;
    message += `   ‚Ä¢ Annonces extraites : ${extractionStats.totalAnnonces}\n`;
    message += `   ‚Ä¢ Annonces sauvegard√©es : ${savedCount}\n`;

    if (saveErrors > 0) {
      message += `   ‚Ä¢ Erreurs sauvegarde : ${saveErrors}\n`;
    }

    // D√©tails par page (tri√©s par num√©ro de page)
    message += `\nüìÑ *D√©tails par page*\n`;
    for (const page of extractionStats.pageDetails) {
      if (page.status === 'success') {
        message += `   ‚Ä¢ Page ${page.pageNumber} : ${page.annoncesCount} annonces\n`;
      } else {
        message += `   ‚Ä¢ Page ${page.pageNumber} : ‚ùå Erreur\n`;
      }
    }

    // Liste des erreurs si pr√©sentes
    if (extractionStats.errors && extractionStats.errors.length > 0) {
      message += `\n‚ùå *Erreurs rencontr√©es*\n`;
      for (const err of extractionStats.errors) {
        const shortError = err.error.length > 50 ? err.error.substring(0, 50) + '...' : err.error;
        message += `   ‚Ä¢ Page ${err.pageNumber} : ${shortError}\n`;
      }
      message += `\n‚ö†Ô∏è Extraction partielle - V√©rifier les logs`;
    } else if (saveErrors > 0) {
      message += `\n‚ö†Ô∏è ${saveErrors} erreur(s) lors de la sauvegarde - V√©rifier les logs`;
    } else {
      message += `\n${statusEmoji} Aucune erreur`;
    }

    // Envoyer la notification √† l'admin
    await bot.api.sendMessage(adminChatId, message, {
      parse_mode: 'Markdown'
    });

    console.log(`‚úÖ Rapport d'extraction envoy√© √† l'admin`);
  } catch (notifyError) {
    // Ne pas bloquer le flux principal si la notification √©choue
    console.error('‚ùå Erreur lors de l\'envoi du rapport d\'extraction:', notifyError);
  }
}

/**
 * Cr√©e et configure le bot Telegram
 * @param {string} token - Le token du bot Telegram
 * @returns {Bot} Instance du bot configur√©e
 */
export function createBot(token) {
  const bot = new Bot(token);

  // Commande /start - Pr√©sentation du bot
  bot.command('start', async (ctx) => {
    const chatId = ctx.chat.id;

    const welcomeMessage = `
üëã Bonjour ! Je suis *ZoomChat*, votre assistant virtuel pour les petites annonces du *Zoom Hebdo* üá¨üá¶

üì∞ *Le Zoom Hebdo*, c'est le journal N¬∞1 d'annonces contr√¥l√©es au Gabon, publi√© chaque vendredi.

üîç *Je peux vous aider √† trouver* :
‚Ä¢ üè† Immobilier (locations, ventes, terrains)
‚Ä¢ üöó V√©hicules (voitures, utilitaires)
‚Ä¢ üíº Emplois (offres d'emploi, formations)
‚Ä¢ üì¶ Objets (mat√©riel, √©quipements)
‚Ä¢ ü§ù Services et rencontres
‚Ä¢ üè™ Fonds de commerce

üí¨ *Comment √ßa marche ?*
Envoyez-moi simplement votre recherche en message et je parcourrai toutes les annonces pour vous !

*Exemples de recherches :*
‚Ä¢ "studio √† louer Libreville"
‚Ä¢ "Toyota occasion"
‚Ä¢ "cherche m√©nag√®re"
‚Ä¢ "terrain √† vendre Ntoum"
‚Ä¢ "emploi chauffeur"

üìã *Commandes utiles* :
/aide - Voir plus d'exemples
/dernier - Recevoir le dernier PDF publi√©
/abonner - Recevoir le PDF chaque vendredi
/desabonner - Annuler l'abonnement

‚ú® Essayez maintenant ! Tapez ce que vous cherchez...
    `.trim();

    // V√©rifier si l'utilisateur est abonn√©
    const subscriber = await getSubscriber(chatId);
    const isSubscribed = subscriber && subscriber.actif;

    // Afficher le bouton S'abonner uniquement si l'utilisateur n'est pas abonn√©
    const replyMarkup = isSubscribed ? {} : {
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üì¨ S\'abonner', callback_data: 'subscribe' }]
        ]
      }
    };

    await ctx.reply(welcomeMessage, {
      parse_mode: 'Markdown',
      ...replyMarkup
    });
  });

  // Commande /test
  bot.command('test', async (ctx) => {
    const msg = 'üöÄ Lancement du test d\'extraction des annonces...';
    await ctx.reply(msg);
  });

  // Commande /dernier - Envoie le dernier PDF publi√©
  bot.command('dernier', async (ctx) => {
    try {
      await ctx.replyWithChatAction('upload_document');

      // R√©cup√©rer la derni√®re parution
      const latestParution = await getLatestParution();

      if (!latestParution) {
        await ctx.reply(
          '‚ùå Aucune parution disponible pour le moment.\n\n' +
          'Les nouvelles parutions seront disponibles chaque vendredi.'
        );
        return;
      }

      // Pr√©parer le message de caption
      const caption = `üì∞ *Zoom Hebdo N¬∞${latestParution.numero}*\n` +
        `üìÖ ${latestParution.periode}\n\n` +
        '‚úÖ Voici la derni√®re parution disponible !';

      // Nom du fichier personnalis√©
      const fileName = `Zoom_Hebdo_${latestParution.numero}.pdf`;

      // Essayer d'abord avec le file_id, puis avec l'URL en fallback
      try {
        await ctx.replyWithDocument(latestParution.telegram_file_id, {
          caption,
          parse_mode: 'Markdown',
          filename: fileName
        });
        console.log(`‚úÖ PDF envoy√© √† ${ctx.chat.id} via file_id: Parution ${latestParution.numero}`);
      } catch (fileIdError) {
        // Si le file_id ne fonctionne pas, utiliser l'URL avec InputFile
        console.warn(`‚ö†Ô∏è File ID invalide, utilisation de l'URL: ${fileIdError.message}`);
        const inputFile = new InputFile(new URL(latestParution.pdf_url), fileName);
        await ctx.replyWithDocument(inputFile, {
          caption,
          parse_mode: 'Markdown'
        });
        console.log(`‚úÖ PDF envoy√© √† ${ctx.chat.id} via URL: Parution ${latestParution.numero}`);
      }

    } catch (error) {
      console.error('Erreur commande /dernier:', error);
      await ctx.reply(
        '‚ùå Une erreur est survenue lors de l\'envoi du PDF.\n\n' +
        'Veuillez r√©essayer dans quelques instants.'
      );
    }
  });

  // Commande /aide (remplace /help)
  bot.command('aide', async (ctx) => {
    const chatId = ctx.chat.id;

    const helpMessage = `
‚ÑπÔ∏è *Aide - ZoomChat*

üîé *Comment rechercher une annonce ?*
Envoyez-moi un message d√©crivant ce que vous cherchez. Je parcourrai les annonces du Zoom Hebdo pour vous.

üìù *Exemples de recherches* :
‚Ä¢ appartement 3 chambres Owendo
‚Ä¢ voiture Toyota moins de 5 millions
‚Ä¢ emploi chauffeur permis CD
‚Ä¢ cherche nounou log√©e
‚Ä¢ terrain √† vendre Ntoum
‚Ä¢ salon de coiffure √† c√©der

üè∑Ô∏è *Cat√©gories disponibles* :
üè† Immobilier - üöó V√©hicules - üíº Emploi
üì¶ Objets - ü§ù People - üè™ Commerce

üì¨ *Commandes disponibles* :
‚Ä¢ /dernier - Recevez le dernier PDF publi√©
‚Ä¢ /abonner - Recevez le PDF chaque vendredi automatiquement
‚Ä¢ /desabonner - Annulez votre abonnement
    `.trim();

    // V√©rifier si l'utilisateur est abonn√©
    const subscriber = await getSubscriber(chatId);
    const isSubscribed = subscriber && subscriber.actif;

    // Afficher le bouton S'abonner uniquement si l'utilisateur n'est pas abonn√©
    const replyMarkup = isSubscribed ? {} : {
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üì¨ S\'abonner', callback_data: 'subscribe' }]
        ]
      }
    };

    await ctx.reply(helpMessage, {
      parse_mode: 'Markdown',
      ...replyMarkup
    });
  });

  // Commande /abonner - S'abonner aux publications automatiques
  bot.command('abonner', async (ctx) => {
    try {
      const chatId = ctx.chat.id;

      // V√©rifier si l'utilisateur est d√©j√† abonn√©
      const existingSubscriber = await getSubscriber(chatId);

      if (existingSubscriber && existingSubscriber.actif) {
        await ctx.reply(
          '‚úÖ Vous √™tes d√©j√† abonn√© aux notifications du Zoom Hebdo !\n\n' +
          `üìÖ Date d'abonnement : ${new Date(existingSubscriber.date_abonnement).toLocaleDateString('fr-FR')}\n\n` +
          'Vous recevrez automatiquement le PDF chaque vendredi.'
        );
        return;
      }

      // R√©cup√©rer le nom de l'utilisateur depuis Telegram
      const nom = `${ctx.from.first_name || ''} ${ctx.from.last_name || ''}`.trim() || 'Utilisateur';

      // Abonner l'utilisateur imm√©diatement (sans num√©ro de t√©l√©phone)
      await addSubscriber(chatId, nom, null);

      // Notifier l'admin du nouvel abonnement
      await notifyAdmin(bot, 'subscribe', {
        nom,
        username: ctx.from.username,
        chatId,
        date: new Date()
      });

      // Message de confirmation
      await ctx.reply(
        'üéâ *Abonnement confirm√© !*\n\n' +
        `üë§ Nom : ${nom}\n` +
        `üìÖ Date : ${new Date().toLocaleDateString('fr-FR')}\n\n` +
        '‚úÖ Vous recevrez d√©sormais le PDF du Zoom Hebdo automatiquement chaque vendredi.\n\n' +
        'üí° Pour vous d√©sabonner, utilisez la commande /desabonner',
        {
          parse_mode: 'Markdown',
          reply_markup: { remove_keyboard: true }
        }
      );
    } catch (error) {
      console.error('Erreur commande /abonner:', error);

      // Notifier l'admin de l'erreur
      const nom = `${ctx.from.first_name || ''} ${ctx.from.last_name || ''}`.trim() || 'Utilisateur';
      await notifyAdmin(bot, 'subscribe', {
        nom,
        username: ctx.from.username,
        chatId,
        date: new Date()
      }, error.message);

      await ctx.reply('‚ùå Une erreur est survenue. Veuillez r√©essayer plus tard.');
    }
  });

  // Commande /desabonner - Se d√©sabonner des notifications
  bot.command('desabonner', async (ctx) => {
    try {
      const chatId = ctx.chat.id;

      // V√©rifier si l'utilisateur est abonn√©
      const subscriber = await getSubscriber(chatId);

      if (!subscriber || !subscriber.actif) {
        await ctx.reply(
          '‚ùå Vous n\'√™tes pas abonn√© aux notifications.\n\n' +
          'Utilisez /abonner pour vous abonner.'
        );
        return;
      }

      // R√©cup√©rer le nom de l'utilisateur depuis Telegram
      const nom = `${ctx.from.first_name || ''} ${ctx.from.last_name || ''}`.trim() || 'Utilisateur';

      // D√©sactiver l'abonnement
      const success = await removeSubscriber(chatId);

      if (success) {
        // Notifier l'admin du d√©sabonnement
        await notifyAdmin(bot, 'unsubscribe', {
          nom,
          username: ctx.from.username,
          chatId,
          date: new Date()
        });

        await ctx.reply(
          '‚úÖ D√©sabonnement effectu√©\n\n' +
          'Vous ne recevrez plus les notifications automatiques du Zoom Hebdo.\n\n' +
          'üí° Vous pouvez vous r√©abonner √† tout moment avec la commande /abonner'
        );
      } else {
        await ctx.reply('‚ùå Une erreur est survenue. Veuillez r√©essayer.');
      }
    } catch (error) {
      console.error('Erreur commande /desabonner:', error);

      // Notifier l'admin de l'erreur
      const nom = `${ctx.from.first_name || ''} ${ctx.from.last_name || ''}`.trim() || 'Utilisateur';
      await notifyAdmin(bot, 'unsubscribe', {
        nom,
        username: ctx.from.username,
        chatId,
        date: new Date()
      }, error.message);

      await ctx.reply('‚ùå Une erreur est survenue. Veuillez r√©essayer plus tard.');
    }
  });

  // Gestionnaire du bouton "S'abonner"
  bot.callbackQuery('subscribe', async (ctx) => {
    try {
      await ctx.answerCallbackQuery(); // R√©pondre au callback pour enlever l'indicateur de chargement

      const chatId = ctx.chat.id;

      // V√©rifier si l'utilisateur est d√©j√† abonn√©
      const existingSubscriber = await getSubscriber(chatId);

      if (existingSubscriber && existingSubscriber.actif) {
        await ctx.reply(
          '‚úÖ Vous √™tes d√©j√† abonn√© aux notifications du Zoom Hebdo !\n\n' +
          `üìÖ Date d'abonnement : ${new Date(existingSubscriber.date_abonnement).toLocaleDateString('fr-FR')}\n\n` +
          'Vous recevrez automatiquement le PDF chaque vendredi.'
        );
        return;
      }

      // R√©cup√©rer le nom de l'utilisateur depuis Telegram
      const nom = `${ctx.from.first_name || ''} ${ctx.from.last_name || ''}`.trim() || 'Utilisateur';

      // Abonner l'utilisateur imm√©diatement (sans num√©ro de t√©l√©phone)
      await addSubscriber(chatId, nom, null);

      // Notifier l'admin du nouvel abonnement
      await notifyAdmin(bot, 'subscribe', {
        nom,
        username: ctx.from.username,
        chatId,
        date: new Date()
      });

      // Message de confirmation
      await ctx.reply(
        'üéâ *Abonnement confirm√© !*\n\n' +
        `üë§ Nom : ${nom}\n` +
        `üìÖ Date : ${new Date().toLocaleDateString('fr-FR')}\n\n` +
        '‚úÖ Vous recevrez d√©sormais le PDF du Zoom Hebdo automatiquement chaque vendredi.\n\n' +
        'üí° Pour vous d√©sabonner, utilisez la commande /desabonner',
        { parse_mode: 'Markdown' }
      );
    } catch (error) {
      console.error('Erreur callback subscribe:', error);

      // Notifier l'admin de l'erreur
      const nom = `${ctx.from.first_name || ''} ${ctx.from.last_name || ''}`.trim() || 'Utilisateur';
      await notifyAdmin(bot, 'subscribe', {
        nom,
        username: ctx.from.username,
        chatId,
        date: new Date()
      }, error.message);

      await ctx.reply('‚ùå Une erreur est survenue. Veuillez r√©essayer plus tard.');
    }
  });

  // Handler pour les messages texte - Recherche d'annonces
  bot.on('message:text', async (ctx) => {
    try {
      const query = ctx.message.text;

      // Ignorer les commandes (d√©j√† g√©r√©es par les handlers de commande)
      if (query.startsWith('/')) {
        return;
      }

      // Limiter la taille du message pour √©viter les abus
      if (query.length > 200) {
        await ctx.reply(
          '‚ö†Ô∏è Votre recherche est trop longue.\n\n' +
          'Veuillez limiter votre recherche √† 200 caract√®res maximum.'
        );
        return;
      }

      // Afficher un indicateur de saisie
      await ctx.replyWithChatAction('typing');

      console.log(`üîç Recherche pour "${query}"`);

      // Effectuer la recherche (limit√© √† 10 r√©sultats)
      const resultats = await searchAnnonces(query, 10);

      if (resultats.length === 0) {
        await ctx.reply(
          'üòî *Aucune annonce trouv√©e*\n\n' +
          `Je n'ai pas trouv√© d'annonces correspondant √† "${query}".\n\n` +
          'üí° *Conseils* :\n' +
          '‚Ä¢ Essayez avec des mots-cl√©s plus simples\n' +
          '‚Ä¢ V√©rifiez l\'orthographe\n' +
          '‚Ä¢ Utilisez des termes g√©n√©riques (ex: "studio" au lieu de "studio meubl√© avec piscine")',
          { parse_mode: 'Markdown' }
        );
        return;
      }

      // Formater les r√©sultats
      let response = `üîç *${resultats.length} annonce${resultats.length > 1 ? 's' : ''} trouv√©e${resultats.length > 1 ? 's' : ''}*\n`;
      response += `üìù Recherche : "${query}"\n\n`;
      response += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n';

      resultats.forEach((annonce, index) => {
        // Construire l'affichage avec les nouveaux champs
        response += `${index + 1}. ${annonce.category ? `*[${annonce.category}]*` : ''}\n`;

        // Titre en gras
        if (annonce.title) {
          response += `*${annonce.title}*\n`;
        }

        // Description (tronqu√©e si trop longue)
        if (annonce.description && annonce.description.length > 0) {
          const description = annonce.description.length > 150
            ? annonce.description.substring(0, 150) + '...'
            : annonce.description;
          response += `${description}\n`;
        }

        // Informations compl√©mentaires
        if (annonce.subcategory) {
          response += `üè∑Ô∏è ${annonce.subcategory}\n`;
        }
        if (annonce.location) {
          response += `üìç ${annonce.location}\n`;
        }
        if (annonce.price) {
          response += `üí∞ ${annonce.price}\n`;
        }
        if (annonce.contact) {
          response += `üìû ${annonce.contact}\n`;
        }
        if (annonce.reference) {
          response += `üîñ R√©f: ${annonce.reference}\n`;
        }

        response += '\n';
      });

      // Si plus de r√©sultats disponibles
      if (resultats.length === 10) {
        response += 'üí° _Seuls les 10 premiers r√©sultats sont affich√©s. Affinez votre recherche pour des r√©sultats plus pr√©cis._';
      }

      await ctx.reply(response, { parse_mode: 'Markdown' });

    } catch (error) {
      console.error('Erreur recherche annonces:', error);
      await ctx.reply(
        '‚ùå Une erreur est survenue lors de la recherche.\n\n' +
        'Veuillez r√©essayer dans quelques instants.'
      );
    }
  });

  // Gestion des erreurs
  bot.catch((err) => {
    console.error('Erreur du bot:', err);
  });

  return bot;
}
